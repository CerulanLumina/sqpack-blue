use super::SCDEntry;
use super::SCDEntryHeader;
use super::decoding::{read_i16, read_i32, read_i64};
use ::FFXIVError;

use std::io::Write;

#[derive(Eq, PartialEq)]
pub enum SCDOggCryptType {
    None,
    VorbisHeaderXor,
    FullXorUsingTable
}

impl SCDOggCryptType {
    fn from(v: i16) -> Result<SCDOggCryptType, FFXIVError> {
        match v {
            // might need to be switched for endian
            0x0 => Ok(SCDOggCryptType::None),
            0x2002 => Ok(SCDOggCryptType::VorbisHeaderXor),
            0x2003 => Ok(SCDOggCryptType::FullXorUsingTable),
            _ => Err(FFXIVError::DecodingSCD(Box::new(FFXIVError::Custom(format!("Unknown ogg crypt type.")))))
        }
    }
}

pub struct SCDEntryOgg {

    header: SCDEntryHeader,
    decoded: Vec<u8>

}

const CRYPT_TYPE_OFFSET: usize = 0x00;
const XOR_VALUE_OFFSET: usize = 0x02;
const SEEK_TABLE_SIZE_OFFSET: usize = 0x10;
const VORBIS_HEADER_SIZE_OFFSET: usize = 0x14;

impl SCDEntry for SCDEntryOgg {

    fn create(buffer: &[u8], header: SCDEntryHeader, chunks_offset: &u32, data_offset: &u32, little_end: &bool) -> Result<Box<SCDEntryOgg>, FFXIVError> {

        let crypt_type = SCDOggCryptType::from(read_i16(&(*data_offset as usize + CRYPT_TYPE_OFFSET), buffer, little_end)?)?;
        let seek_table_size  = read_i32(&(*data_offset as usize + SEEK_TABLE_SIZE_OFFSET), buffer, little_end)?;
        let vorbis_header_size  = read_i32(&(*data_offset as usize + VORBIS_HEADER_SIZE_OFFSET), buffer, little_end)?;
        let vorbis_header_offset = *data_offset as usize + 0x20 + seek_table_size as usize;
        let sound_data_offset = vorbis_header_offset + vorbis_header_size as usize;
        let mut vorbis_header = Vec::<u8>::with_capacity(vorbis_header_size as usize);

        vorbis_header.write_all(&buffer[vorbis_header_offset..vorbis_header_offset+vorbis_header_size as usize])
            .map_err(|e| FFXIVError::DecodingSCD(Box::new(e)))?;

        if crypt_type == SCDOggCryptType::VorbisHeaderXor {
            let xor_val = buffer[*data_offset as usize + XOR_VALUE_OFFSET];
            if xor_val != 0 {
                for i in 0..vorbis_header.len() {
                    vorbis_header[i] = vorbis_header[i] ^ xor_val;
                }
            }
        }

        let mut decoded = Vec::<u8>::with_capacity(vorbis_header.len() + header.data_size as usize);
        decoded.write_all(&vorbis_header[0..vorbis_header.len()])
            .map_err(|e| FFXIVError::DecodingSCD(Box::new(e)))?;
        decoded.write_all(&buffer[sound_data_offset..sound_data_offset+header.data_size as usize])
            .map_err(|e| FFXIVError::DecodingSCD(Box::new(e)))?;

        if crypt_type == SCDOggCryptType::FullXorUsingTable {
            let static_xor = (header.data_size & 0x7f) as u8;
            let table_offset = (header.data_size & 0x3f) as usize;
            decoded.iter_mut().enumerate().for_each(|(index, byte)| {
                *byte = *byte ^ XOR_TABLE[(table_offset + index) & 0xff];
                *byte = *byte ^ static_xor;
            });
        }

        Ok(Box::new(SCDEntryOgg{
            header,
            decoded
        }))
    }

    fn decoded(&self) -> &Vec<u8> {
        &self.decoded
    }

    fn header(&self) -> &SCDEntryHeader {
        &self.header
    }

}



const XOR_TABLE: [u8; 256] = [
    0x3A, 0x32, 0x32, 0x32, 0x03, 0x7E, 0x12, 0xF7,
    0xB2, 0xE2, 0xA2, 0x67, 0x32, 0x32, 0x22, 0x32,
    0x32, 0x52, 0x16, 0x1B, 0x3C, 0xA1, 0x54, 0x7B,
    0x1B, 0x97, 0xA6, 0x93, 0x1A, 0x4B, 0xAA, 0xA6,
    0x7A, 0x7B, 0x1B, 0x97, 0xA6, 0xF7, 0x02, 0xBB,
    0xAA, 0xA6, 0xBB, 0xF7, 0x2A, 0x51, 0xBE, 0x03,
    0xF4, 0x2A, 0x51, 0xBE, 0x03, 0xF4, 0x2A, 0x51,
    0xBE, 0x12, 0x06, 0x56, 0x27, 0x32, 0x32, 0x36,
    0x32, 0xB2, 0x1A, 0x3B, 0xBC, 0x91, 0xD4, 0x7B,
    0x58, 0xFC, 0x0B, 0x55, 0x2A, 0x15, 0xBC, 0x40,
    0x92, 0x0B, 0x5B, 0x7C, 0x0A, 0x95, 0x12, 0x35,
    0xB8, 0x63, 0xD2, 0x0B, 0x3B, 0xF0, 0xC7, 0x14,
    0x51, 0x5C, 0x94, 0x86, 0x94, 0x59, 0x5C, 0xFC,
    0x1B, 0x17, 0x3A, 0x3F, 0x6B, 0x37, 0x32, 0x32,
    0x30, 0x32, 0x72, 0x7A, 0x13, 0xB7, 0x26, 0x60,
    0x7A, 0x13, 0xB7, 0x26, 0x50, 0xBA, 0x13, 0xB4,
    0x2A, 0x50, 0xBA, 0x13, 0xB5, 0x2E, 0x40, 0xFA,
    0x13, 0x95, 0xAE, 0x40, 0x38, 0x18, 0x9A, 0x92,
    0xB0, 0x38, 0x00, 0xFA, 0x12, 0xB1, 0x7E, 0x00,
    0xDB, 0x96, 0xA1, 0x7C, 0x08, 0xDB, 0x9A, 0x91,
    0xBC, 0x08, 0xD8, 0x1A, 0x86, 0xE2, 0x70, 0x39,
    0x1F, 0x86, 0xE0, 0x78, 0x7E, 0x03, 0xE7, 0x64,
    0x51, 0x9C, 0x8F, 0x34, 0x6F, 0x4E, 0x41, 0xFC,
    0x0B, 0xD5, 0xAE, 0x41, 0xFC, 0x0B, 0xD5, 0xAE,
    0x41, 0xFC, 0x3B, 0x70, 0x71, 0x64, 0x33, 0x32,
    0x12, 0x32, 0x32, 0x36, 0x70, 0x34, 0x2B, 0x56,
    0x22, 0x70, 0x3A, 0x13, 0xB7, 0x26, 0x60, 0xBA,
    0x1B, 0x94, 0xAA, 0x40, 0x38, 0x00, 0xFA, 0xB2,
    0xE2, 0xA2, 0x67, 0x32, 0x32, 0x12, 0x32, 0xB2,
    0x32, 0x32, 0x32, 0x32, 0x75, 0xA3, 0x26, 0x7B,
    0x83, 0x26, 0xF9, 0x83, 0x2E, 0xFF, 0xE3, 0x16,
    0x7D, 0xC0, 0x1E, 0x63, 0x21, 0x07, 0xE3, 0x01
];